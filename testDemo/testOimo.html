<html>

<head>
    <meta charset="UTF-8">
    <title>html</title>
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black"/>
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, target-densitydpi=device-dpi"
    />
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
    <script src="../example/dat.gui.min.js"></script>
    <script src="../release/RedGL.min.js"></script>
    <script src="oimo.min.js"></script>
</head>

<body>
<canvas id="test" style="border: none;"></canvas>
<script>
    document.getElementById('test')
    RedGL(document.getElementById('test'), function (v) {
        console.log(v)
        var tGL;
        var tWorld, tScene3D, tCamera
        var tRenderer;
        var self;
        self = this
        tGL = this.gl;
        this.world = tWorld = RedWorld();
        tScene3D = RedScene(this);
        // tScene3D['useFog'] = true
        tCamera = RedObitController(this);
        tCamera.tilt = -45
        tCamera.distance = 1250
        tCamera.speedDistance = 50
        tRenderer = RedRenderer();
        tRenderer.setDebugButton()
        tWorld.addView(RedView('test', this, tScene3D, tCamera));
        RedView('test').setSize('100%', '100%')
        RedView('test').setLocation('0%', '0%')
        this.renderScale = 1
        var testDLight;
        testDLight = RedDirectionalLight(this)
        testDLight.x = 0
        testDLight.y = 300
        testDLight.z = 300

        tScene3D.addLight(testDLight)


        var tShadow = RedDirectionalShadow(self, testDLight)
        tScene3D.shadowManager.directionalShadow = tShadow
        tShadow.width = 512
        tShadow.height = 512
        tShadow.size = 700
        tScene3D.skyBox =
            RedSkyBox(this, [
                '../asset/cubemap/SwedishRoyalCastle/px.jpg',
                '../asset/cubemap/SwedishRoyalCastle/nx.jpg',
                '../asset/cubemap/SwedishRoyalCastle/py.jpg',
                '../asset/cubemap/SwedishRoyalCastle/ny.jpg',
                '../asset/cubemap/SwedishRoyalCastle/pz.jpg',
                '../asset/cubemap/SwedishRoyalCastle/nz.jpg'
            ]);


        /////////////////////////
        var world
        var type
        var bodys
        var grounds = []
        var meshs = []

        var clearMesh = function () {
            console.log('클리에 메쉬')
            var i = meshs.length;
            while (i--) tScene3D.removeChild(meshs[i]);
            i = grounds.length;
            while (i--) tScene3D.removeChild(grounds[i]);
            grounds = [];
            meshs = [];
        }

        function addStaticBox(size, position, rotation) {
            var mesh = RedMesh(self, RedBox(self), RedStandardMaterial(self, RedBitmapTexture(self, '../asset/brick/Brick03_col.jpg')))
            mesh.scaleX = size[0]
            mesh.scaleY = size[1]
            mesh.scaleZ = size[2]

            mesh.rotationX = rotation[0]
            mesh.rotationY = rotation[1]
            mesh.rotationZ = rotation[2]

            mesh.x = position[0]
            mesh.y = position[1]
            mesh.z = position[2]

            tScene3D.addChild(mesh);
            grounds.push(mesh);
            tScene3D.grid = RedGrid(self, 400)
        }

        function updateOimoPhysics() {
            if (world == null) return;

            world.step();

            var x, y, z, mesh, body, i = bodys.length;

            while (i--) {
                body = bodys[i];
                mesh = meshs[i];

                if (!body.sleeping) {

                    // console.log(body)
                    mesh.x = body.pos.x
                    mesh.y = body.pos.y
                    mesh.z = body.pos.z
                    var tRotation = [0, 0, 0]
                    var q = [body.quaternion.x, body.quaternion.y, body.quaternion.z, body.quaternion.w]
                    tRotation = RedGLUtil.quaternionToRotation(q)
                    mesh.rotationX = tRotation[0] * 180 / Math.PI
                    mesh.rotationY = tRotation[1] * 180 / Math.PI
                    mesh.rotationZ = tRotation[2] * 180 / Math.PI

                    // change material
                    if (mesh._geometry instanceof RedSphere) mesh.material = tMat1;
                    else if (mesh._geometry instanceof RedBox) mesh.material = tMat2;
                    // if(mesh.geometry instanceof RedSphere mesh.material = tMat3;

                    // reset position
                    if (mesh.y < -400) {
                        x = -100 + Math.random() * 200;
                        z = -100 + Math.random() * 200;
                        y = 1000 + Math.random() * 100;
                        body.resetPosition(x, y, z);
                    }
                } else {
                    if (mesh._material != tMat0) mesh.material = tMat0;
                }
            }
            //
            // infos.innerHTML = world.getInfo();
        }

        function initOimoPhysics() {

            // world setting:( TimeStep, BroadPhaseType, Iterations )
            // BroadPhaseType can be
            // 1 : BruteForce
            // 2 : Sweep and prune , the default
            // 3 : dynamic bounding volume tree

            world = new OIMO.World({info: true, worldscale: 100, gravity: [0, -9.8, 0]});
            populate(1);
            //setInterval(updateOimoPhysics, 1000/60);

        }

        initOimoPhysics()

        var tMat1
        var tMat2
        var tMat3
        var tMat0

        function populate(n) {

            tMat1 = RedStandardMaterial(self, RedBitmapTexture(self, '../asset/brick/Brick03_col.jpg'))
            tMat2 = RedStandardMaterial(self, RedBitmapTexture(self, '../asset/draft2.png'))
            tMat3 = RedStandardMaterial(self, RedBitmapTexture(self, '../asset/brick/Brick03_col.jpg'))
            tMat0 = RedColorPhongMaterial(self)
            var max = 750;

            if (n === 1) type = 1
            else if (n === 2) type = 2;
            else if (n === 3) type = 3;
            else if (n === 4) type = 4;

            // reset old
            clearMesh();
            world.clear();
            bodys = [];

            //add ground
            var ground0 = world.add({size: [40, 40, 390], pos: [-180, 20, 0], world: world});
            var ground1 = world.add({size: [40, 40, 390], pos: [180, 20, 0], world: world});
            var ground2 = world.add({size: [400, 400, 400], pos: [0, -200, 0], world: world});
            var ground3 = world.add({size: [600, 400, 600], pos: [0, -400, 0], world: world});


            addStaticBox([40, 40, 390], [-180, 20, 0], [0, 0, 0]);
            addStaticBox([40, 40, 390], [180, 20, 0], [0, 0, 0]);
            addStaticBox([400, 400, 400], [0, -200, 0], [0, 0, 0]);
            addStaticBox([600, 400, 600], [0, -400, 0], [0, 0, 0]);

            //add object
            var x, y, z, w, h, d;
            var i = max;

            while (i--) {
                if (type === 4) t = Math.floor(Math.random() * 3) + 1;
                else t = type;
                x = -100 + Math.random() * 200;
                z = -100 + Math.random() * 200;
                y = 100 + i * 5;
                w = 15 + Math.random() * 20;
                h = 15 + Math.random() * 20;
                d = 15 + Math.random() * 20;
                t = i > max / 2 ? 1 : 2
                if (t == 3) t = 2
                if (t === 1) {
                    bodys[i] = world.add({type: 'sphere', size: [w * 0.5], pos: [x, y, z], move: true, world: world});
                    meshs[i] = RedMesh(self, RedSphere(self, w * 0.5, 16, 16, 16), tMat1)

                } else if (t === 2) {
                    bodys[i] = world.add({type: 'box', size: [w, h, d], pos: [x, y, z], move: true, world: world});
                    meshs[i] = RedMesh(self, RedBox(self, w, h, d), tMat2)


                } else if (t === 3) {
                    bodys[i] = world.add({
                        type: 'cylinder',
                        size: [w * 0.5, h],
                        pos: [x, y, z],
                        move: true,
                        world: world
                    });
                    meshs[i] = RedMesh(self, RedSphere(self), tMat3)
                }


                tScene3D.addChild(meshs[i]);
                tShadow.addCasting(meshs[i])
            }
        }

        tRenderer.start(this, function (time) {
            updateOimoPhysics();

        })

        console.log(tScene3D)
    })
</script>
</body>

</html>